[
  {
    "objectID": "index.html#notebooks",
    "href": "index.html#notebooks",
    "title": "Master’s Project",
    "section": "Notebooks",
    "text": "Notebooks"
  },
  {
    "objectID": "notebooks/02-UMAP-HDBSCAN.html",
    "href": "notebooks/02-UMAP-HDBSCAN.html",
    "title": "Reproducing Chen et. al. (2021)’s unsupervised machine learning",
    "section": "",
    "text": "Note\n\n\n\n📌 Goal: This notebook tries to reproduce the results from https://ui.adsabs.harvard.edu/abs/2022MNRAS.509.1227C/abstract. As stated in the paper, verbatim\n\nOur goal is to map several observational and model-dependent parameters of each FRB to a 2D embedding plane by training the UMAP algorithm on the features of the training samples in CHIME/FRB dataset and finally identify possibly misclassified non-repeating FRBs which in fact have latent features of repeating FRBs. We define these possibly misclassified non-repeating FRBs as FRB repeater candidates in our paper."
  },
  {
    "objectID": "notebooks/02-UMAP-HDBSCAN.html#getting-the-data",
    "href": "notebooks/02-UMAP-HDBSCAN.html#getting-the-data",
    "title": "Reproducing Chen et. al. (2021)’s unsupervised machine learning",
    "section": "0. Getting the Data",
    "text": "0. Getting the Data\n\n0.1 Source\nThe paper uses data from CHIME/FRB Catalog with parameters calculated in Hashimoto et. al. 2022.\n\ncatalog: pd.DataFrame = pd.read_csv('../data/raw/external/Hashimoto2022_chimefrbcat1.csv')\ncatalog\n\n\n\n\n\n  \n    \n      \n      tns_name\n      previous_name\n      repeater_name\n      ra\n      ra_err\n      ra_notes\n      dec\n      dec_err\n      dec_notes\n      gl\n      ...\n      weight_fluence_error_m\n      weight\n      weight_error_p\n      weight_error_m\n      weighted_logrhoA\n      weighted_logrhoA_error_p\n      weighted_logrhoA_error_m\n      weighted_logrhoB\n      weighted_logrhoB_error_p\n      weighted_logrhoB_error_m\n    \n  \n  \n    \n      0\n      FRB20180725A\n      180725.J0613+67\n      -9999\n      93.42\n      0.04\n      -9999\n      67.10\n      0.20\n      -9999\n      147.29\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      1\n      FRB20180727A\n      180727.J1311+26\n      -9999\n      197.70\n      0.10\n      -9999\n      26.40\n      0.30\n      -9999\n      24.76\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      2\n      FRB20180729A\n      180729.J1316+55\n      -9999\n      199.40\n      0.10\n      -9999\n      55.58\n      0.08\n      -9999\n      115.26\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      3\n      FRB20180729B\n      180729.J0558+56\n      -9999\n      89.90\n      0.30\n      -9999\n      56.50\n      0.20\n      -9999\n      156.90\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      4\n      FRB20180730A\n      180730.J0353+87\n      -9999\n      57.39\n      0.03\n      -9999\n      87.20\n      0.20\n      -9999\n      125.11\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      594\n      FRB20190701A\n      -9999\n      -9999\n      277.50\n      0.20\n      -9999\n      59.00\n      0.20\n      -9999\n      88.29\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      595\n      FRB20190701B\n      -9999\n      -9999\n      302.90\n      0.20\n      -9999\n      80.20\n      0.20\n      -9999\n      112.88\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      596\n      FRB20190701C\n      -9999\n      -9999\n      96.40\n      0.20\n      -9999\n      81.60\n      0.30\n      -9999\n      132.18\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      597\n      FRB20190701D\n      -9999\n      -9999\n      112.10\n      0.20\n      -9999\n      66.70\n      0.20\n      -9999\n      149.28\n      ...\n      0.000649\n      1.361506\n      0.574701\n      0.206776\n      0.813142\n      0.485293\n      0.109293\n      0.894742\n      0.25519\n      0.19035\n    \n    \n      598\n      FRB20190701E\n      -9999\n      -9999\n      138.60\n      0.20\n      -9999\n      61.71\n      0.04\n      -9999\n      153.27\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n  \n\n599 rows × 107 columns\n\n\n\n\n\n0.2 Dataset Validation\nWe first validate that the data is as described in the paper. According to the paper:\n\n\nThe initial dataset includes 501 non-repeating FRB sub-bursts from 474 sources and 93 repeating FRB sub-bursts from 18 sources.\n\n\nThe catalogue includes 535 FRBs at a frequency range between 400 and 800 MHz from 2018 July 25 to 2019 July 1. Since a repeating FRB source provides several FRBs and each FRB might include several sub-bursts, the actual number of applying subburst samples are 501 non-repeating + 93 repeating = 594 sub-bursts.\n\n\nWe can verify this using a simple dataframe method.\n\nstart: float = Time('2018-07-25').mjd\nend: float = Time('2019-07-01').mjd\n\ninterval: pd.Series = (start <= catalog['mjd_400']) & (catalog['mjd_400'] <= end)\ncatalog: pd.DataFrame = catalog[interval]\n\nrepeating: pd.DataFrame = catalog[(catalog['repeater_name'] != \"-9999\")]\nnon_repeating: pd.DataFrame = catalog[(catalog['repeater_name'] == \"-9999\")]\nprint(f\"Total repeaters\\t\\t: {len(repeating)}\",f\"Total non-repeaters\\t: {len(non_repeating)}\", sep=\"\\n\")\nprint(f\"Total sub-bursts\\t: {len(repeating) + len(non_repeating)}\")\n\nTotal repeaters     : 93\nTotal non-repeaters : 501\nTotal sub-bursts    : 594\n\n\n\n\n\n\n\n\nNote\n\n\n\nTODO Apply filter to get the number of sources. This filter only gets the number of sub bursts.\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhat does the authors mean by “The catalogue includes 535 FRBs”? I could not think of a filter that fits the description."
  },
  {
    "objectID": "notebooks/02-UMAP-HDBSCAN.html#preprocessing",
    "href": "notebooks/02-UMAP-HDBSCAN.html#preprocessing",
    "title": "Reproducing Chen et. al. (2021)’s unsupervised machine learning",
    "section": "1. Preprocessing",
    "text": "1. Preprocessing\n\n1.1 Sample dan Selection\nThese are the criteria:\n\nObserved between 2018 July 25 to 2019 July 1. (Already filtered in Validation)\nWe exclude the FRB sub-bursts which have neither flux nor fluence measurements.\nThe input data for unsupervised learning includes a total of 10 observational and 3 model-dependent parameters. (Described in Parameters)\n\n\n\n1.2 Parameters\n\n\n1.2.1 Observational Parameters\nThe parameters selected by the paper is as follows: - Boxcar Width bc_width - Width of Sub-Burst width_fitb - Flux flux - Fluence fluence - Scattering Time scat_time - Spectral Index sp_idx - Spectral Running sp_run - Highest Frequency high_freq - Lowest Frequency low_freq - Peak Frequency peak_freq\n\n\n1.2.2 Model Dependent Parameters\n\nRedshift z\nRadio Energy logE_rest_400\nRest-Frame Intrinsic Duration logsubw_int_rest\n\n\nfrom typing import List\n\nparams : List[str] = [\n    # Observational\n    \"bc_width\",\n    \"width_fitb\",\n    \"flux\",\n    \"fluence\",\n    \"scat_time\",\n    \"sp_idx\",\n    \"sp_run\",\n    \"high_freq\",\n    \"low_freq\",\n    \"peak_freq\",\n    # Model dependent\n    \"z\",\n    \"logE_rest_400\",\n    \"logsubw_int_rest\"\n]\n\nidentifiers: List[str] = [\n    \"tns_name\",\n    \"repeater_name\"\n]\n\ndropna_subset = ['flux', 'fluence', 'logE_rest_400']\n\nnon_repeating = non_repeating[[*params, *identifiers]]\nrepeating = repeating[[*params, *identifiers]]"
  },
  {
    "objectID": "notebooks/02-UMAP-HDBSCAN.html#dimension-reduction",
    "href": "notebooks/02-UMAP-HDBSCAN.html#dimension-reduction",
    "title": "Reproducing Chen et. al. (2021)’s unsupervised machine learning",
    "section": "2. Dimension Reduction",
    "text": "2. Dimension Reduction\n\n2.1 Split test and training data\n\ntest, train = train_test_split(repeating, test_size=0.9)\n\n\n# to be trained\nselected = pd.concat([train, non_repeating]).dropna(subset=dropna_subset)\n\n\n\n2.2 UMAP\nParameters:\n\nn_neighbors = 8\n\nit controls how UMAP balances between the local structure and the global structure of the data manifolds\n\nn_components = 2\n\nthe resulting dimensionality of the reduced dimension\n\nmin_dist = 0.1\n\nto prevent the resulting low dimensional projections clumping together\n\n\n\nmodel: umap.UMAP = umap.UMAP(n_neighbors=8, n_components=2, min_dist=0.1)\nmap = model.fit(selected[params])\ntest_map = map.transform(test[params])\n\n\nselected['x'] = map.embedding_[:, 0]\nselected['y'] = map.embedding_[:, 1]\nselected['color'] = ['non-repeater' if name == '-9999' else 'repeater (train)' for name in selected['repeater_name']]\n\nselected = selected.sort_values(by=['color'])\n\ntest['x'] = test_map[:,0]\ntest['y'] = test_map[:,1]\ntest['color'] = 'repeater (test)'\n\nto_plot = pd.concat([selected, test])\n\nsns.set_style('dark')\nsns.set_context('paper')\nsns.relplot(data=to_plot, kind='scatter', x='x', y='y', hue='color', hue_order=['non-repeater','repeater (train)','repeater (test)'])\n\n<seaborn.axisgrid.FacetGrid at 0x1dff54e50d0>"
  },
  {
    "objectID": "notebooks/02-UMAP-HDBSCAN.html#hdbscan",
    "href": "notebooks/02-UMAP-HDBSCAN.html#hdbscan",
    "title": "Reproducing Chen et. al. (2021)’s unsupervised machine learning",
    "section": "3. HDBSCAN",
    "text": "3. HDBSCAN\nWe now perform HDBSCAN to cluster data based on the dimensionally reduced data from UMAP.\n\n3.1 Calculation\n\nimport hdbscan\n\nThe paper did not classify the minimum cluster size for HDBSCAN so I tried to find a parameter that fits. The minimum cluster size (clus_size) that fits the paper’s model is 19 as calculated by rounding 0.458 * to_plot.shape[1].\n\nconst = 0.485\nclus_size = round(const * to_plot.shape[1])\n\nmodel_ = hdbscan.HDBSCAN(clus_size)\nto_plot['hdbscan'] = model_.fit_predict(to_plot[['x', 'y']])\nto_plot = to_plot.sort_values(by='hdbscan', ascending=True)\nto_plot['hdbscan'] = to_plot['hdbscan'].astype(str)\nsns.relplot(data=to_plot, kind='scatter', x='x', y='y', hue='hdbscan')\n\n<seaborn.axisgrid.FacetGrid at 0x1df8adc3340>\n\n\n\n\n\n\n\n3.2 Comparison\nIn this section we present the data from Chen et al (2021).\n\nchen2021 = pd.read_csv('../data/raw/external/chen2021_classification.csv')\nchen2021['source'] = 'chen et al 2021'\nsns.relplot(data=chen2021, kind='scatter', x='embedding_x', y='embedding_y', hue='group')\n\n<seaborn.axisgrid.FacetGrid at 0x1df8b491fa0>\n\n\n\n\n\nAs you can see, Chen et al (2021) contains 9 clusters while the one we did have 12 clusters. The number of clusters itself is irrelevant but the size of clusters is. What we want to know is whether or not we can replicate the classification of repeater clusters from non-repeater clusters.\nA cluster is considered repeater cluster is the total number of more than 10% repeating FRB exists in the cluster. Other FRBs inside the repeater cluster is determined to be ‘potentially’ repeating. Then, we compare the division between this notebook and Chen et al (2021).\n\n# Determining repeater clusters (>10% is repeater FRB)\nthis = to_plot[['tns_name','x','y', 'hdbscan', 'color']].rename(columns={'x': 'embedding_x', 'y':'embedding_y', 'hdbscan': 'label', 'color': 'repeater'})\nthis['source'] = 'calculated'\nthis['repeater'] = [False if name == 'non-repeater' else True for name in this['repeater']]\na = this.groupby('label').aggregate('mean', numeric_only=True)\na['group'] = ['repeater_cluster' if row > 0.1 else 'other_cluster' for row in a['repeater']]\na.reset_index()\nthis = this.merge(a[['group']], on='label')\n\n# Rename groups to only separate repeater clusters from other clusters\nchen2021['group'] = chen2021['group'].apply(lambda x: x[:-2])\n\ndata: pd.DataFrame = pd.concat([this, chen2021])\nsns.relplot(data=data, kind='scatter', x='embedding_x', y='embedding_y', hue='group', col='source')\n\n<seaborn.axisgrid.FacetGrid at 0x1df8b23fa60>\n\n\n\n\n\nThe division fairly replicates the one from Chen et al. (2021). However, some of the top left corner of the embedding is not classified as repeater in this notebook while it is in Chen et al. (2021). We can continue analysis with more graphs from Chen et al. (2021)."
  },
  {
    "objectID": "notebooks/04-UMAP-HDBSCAN-reduced-params.html",
    "href": "notebooks/04-UMAP-HDBSCAN-reduced-params.html",
    "title": "UMAP-HDBSCAN Reduced Parameters",
    "section": "",
    "text": "Note\n\n\n\n📌 Goal: This notebook tries to reproduce the results from https://ui.adsabs.harvard.edu/abs/2022MNRAS.509.1227C/abstract with reduced parameters."
  },
  {
    "objectID": "notebooks/04-UMAP-HDBSCAN-reduced-params.html#getting-the-data",
    "href": "notebooks/04-UMAP-HDBSCAN-reduced-params.html#getting-the-data",
    "title": "UMAP-HDBSCAN Reduced Parameters",
    "section": "0. Getting the Data",
    "text": "0. Getting the Data\n\n0.1 Source\nThe paper uses data from CHIME/FRB Catalog with parameters calculated in Hashimoto et. al. 2022.\n\ncatalog: pd.DataFrame = pd.read_csv('../data/raw/external/Hashimoto2022_chimefrbcat1.csv')\ncatalog\n\n\n\n\n\n  \n    \n      \n      tns_name\n      previous_name\n      repeater_name\n      ra\n      ra_err\n      ra_notes\n      dec\n      dec_err\n      dec_notes\n      gl\n      ...\n      weight_fluence_error_m\n      weight\n      weight_error_p\n      weight_error_m\n      weighted_logrhoA\n      weighted_logrhoA_error_p\n      weighted_logrhoA_error_m\n      weighted_logrhoB\n      weighted_logrhoB_error_p\n      weighted_logrhoB_error_m\n    \n  \n  \n    \n      0\n      FRB20180725A\n      180725.J0613+67\n      -9999\n      93.42\n      0.04\n      -9999\n      67.10\n      0.20\n      -9999\n      147.29\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      1\n      FRB20180727A\n      180727.J1311+26\n      -9999\n      197.70\n      0.10\n      -9999\n      26.40\n      0.30\n      -9999\n      24.76\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      2\n      FRB20180729A\n      180729.J1316+55\n      -9999\n      199.40\n      0.10\n      -9999\n      55.58\n      0.08\n      -9999\n      115.26\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      3\n      FRB20180729B\n      180729.J0558+56\n      -9999\n      89.90\n      0.30\n      -9999\n      56.50\n      0.20\n      -9999\n      156.90\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      4\n      FRB20180730A\n      180730.J0353+87\n      -9999\n      57.39\n      0.03\n      -9999\n      87.20\n      0.20\n      -9999\n      125.11\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      594\n      FRB20190701A\n      -9999\n      -9999\n      277.50\n      0.20\n      -9999\n      59.00\n      0.20\n      -9999\n      88.29\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      595\n      FRB20190701B\n      -9999\n      -9999\n      302.90\n      0.20\n      -9999\n      80.20\n      0.20\n      -9999\n      112.88\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      596\n      FRB20190701C\n      -9999\n      -9999\n      96.40\n      0.20\n      -9999\n      81.60\n      0.30\n      -9999\n      132.18\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      597\n      FRB20190701D\n      -9999\n      -9999\n      112.10\n      0.20\n      -9999\n      66.70\n      0.20\n      -9999\n      149.28\n      ...\n      0.000649\n      1.361506\n      0.574701\n      0.206776\n      0.813142\n      0.485293\n      0.109293\n      0.894742\n      0.25519\n      0.19035\n    \n    \n      598\n      FRB20190701E\n      -9999\n      -9999\n      138.60\n      0.20\n      -9999\n      61.71\n      0.04\n      -9999\n      153.27\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n  \n\n599 rows × 107 columns\n\n\n\n\n\n0.2 Dataset Validation\nWe first validate that the data is as described in the paper. According to the paper:\n\n\nThe initial dataset includes 501 non-repeating FRB sub-bursts from 474 sources and 93 repeating FRB sub-bursts from 18 sources.\n\n\nThe catalogue includes 535 FRBs at a frequency range between 400 and 800 MHz from 2018 July 25 to 2019 July 1. Since a repeating FRB source provides several FRBs and each FRB might include several sub-bursts, the actual number of applying subburst samples are 501 non-repeating + 93 repeating = 594 sub-bursts.\n\n\nWe can verify this using a simple dataframe method.\n\nstart: float = Time('2018-07-25').mjd\nend: float = Time('2019-07-01').mjd\n\ninterval: pd.Series = (start <= catalog['mjd_400']) & (catalog['mjd_400'] <= end)\ncatalog: pd.DataFrame = catalog[interval]\n\nrepeating: pd.DataFrame = catalog[(catalog['repeater_name'] != \"-9999\")]\nnon_repeating: pd.DataFrame = catalog[(catalog['repeater_name'] == \"-9999\")]\nprint(f\"Total repeaters\\t\\t: {len(repeating)}\",f\"Total non-repeaters\\t: {len(non_repeating)}\", sep=\"\\n\")\nprint(f\"Total sub-bursts\\t: {len(repeating) + len(non_repeating)}\")\n\nTotal repeaters     : 93\nTotal non-repeaters : 501\nTotal sub-bursts    : 594\n\n\n\n\n\n\n\n\nNote\n\n\n\nTODO Apply filter to get the number of sources. This filter only gets the number of sub bursts.\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhat does the authors mean by “The catalogue includes 535 FRBs”? I could not think of a filter that fits the description."
  },
  {
    "objectID": "notebooks/04-UMAP-HDBSCAN-reduced-params.html#preprocessing",
    "href": "notebooks/04-UMAP-HDBSCAN-reduced-params.html#preprocessing",
    "title": "UMAP-HDBSCAN Reduced Parameters",
    "section": "1. Preprocessing",
    "text": "1. Preprocessing\n\n1.1 Sample dan Selection\nThese are the criteria:\n\nObserved between 2018 July 25 to 2019 July 1. (Already filtered in Validation)\nWe exclude the FRB sub-bursts which have neither flux nor fluence measurements.\nThe input data for unsupervised learning includes a total of 10 observational and 3 model-dependent parameters. (Described in Parameters)\n\n\n\n1.2 Parameters\n\n\n1.2.1 Observational Parameters\nThe parameters selected by the paper is as follows: - Boxcar Width bc_width - Width of Sub-Burst width_fitb - Flux flux - Fluence fluence - Scattering Time scat_time - Spectral Index sp_idx - Spectral Running sp_run - Highest Frequency high_freq - Lowest Frequency low_freq - Peak Frequency peak_freq\n\n\n1.2.2 Model Dependent Parameters\n\nRedshift z\nRadio Energy logE_rest_400\nRest-Frame Intrinsic Duration logsubw_int_rest\n\n\nfrom typing import List\n\nparams : List[str] = [\n    # Observational\n    # \"bc_width\",\n    \"width_fitb\",\n    \"flux\",\n    \"fluence\",\n    # \"scat_time\",\n    # \"sp_idx\",\n    # \"sp_run\",\n    # \"high_freq\",\n    # \"low_freq\",\n    \"peak_freq\",\n    # Model dependent\n    \"z\",\n    # \"logE_rest_400\",\n    # \"logsubw_int_rest\"\n]\n\nidentifiers: List[str] = [\n    \"tns_name\",\n    \"repeater_name\"\n]\n\ndropna_subset = ['flux', 'fluence']#, 'logE_rest_400']\n\nnon_repeating = non_repeating[[*params, *identifiers]]\nrepeating = repeating[[*params, *identifiers]]"
  },
  {
    "objectID": "notebooks/04-UMAP-HDBSCAN-reduced-params.html#dimension-reduction",
    "href": "notebooks/04-UMAP-HDBSCAN-reduced-params.html#dimension-reduction",
    "title": "UMAP-HDBSCAN Reduced Parameters",
    "section": "2. Dimension Reduction",
    "text": "2. Dimension Reduction\n\n2.1 Split test and training data\n\ntest, train = train_test_split(repeating, test_size=0.9)\n\n\n# to be trained\nselected = pd.concat([train, non_repeating]).dropna(subset=dropna_subset)\n\n\n\n2.2 UMAP\nParameters:\n\nn_neighbors = 8\n\nit controls how UMAP balances between the local structure and the global structure of the data manifolds\n\nn_components = 2\n\nthe resulting dimensionality of the reduced dimension\n\nmin_dist = 0.1\n\nto prevent the resulting low dimensional projections clumping together\n\n\n\nmodel: umap.UMAP = umap.UMAP(n_neighbors=8, n_components=2, min_dist=0.1)\nmap = model.fit(selected[params])\ntest_map = map.transform(test[params])\n\n\nselected['x'] = map.embedding_[:, 0]\nselected['y'] = map.embedding_[:, 1]\nselected['color'] = ['non-repeater' if name == '-9999' else 'repeater (train)' for name in selected['repeater_name']]\n\nselected = selected.sort_values(by=['color'])\n\ntest['x'] = test_map[:,0]\ntest['y'] = test_map[:,1]\ntest['color'] = 'repeater (test)'\n\nto_plot = pd.concat([selected, test])\n\nsns.set_style('dark')\nsns.set_context('paper')\nsns.relplot(data=to_plot, kind='scatter', x='x', y='y', hue='color', hue_order=['non-repeater','repeater (train)','repeater (test)'])\n\n<seaborn.axisgrid.FacetGrid at 0x1bf99261940>"
  },
  {
    "objectID": "notebooks/04-UMAP-HDBSCAN-reduced-params.html#hdbscan",
    "href": "notebooks/04-UMAP-HDBSCAN-reduced-params.html#hdbscan",
    "title": "UMAP-HDBSCAN Reduced Parameters",
    "section": "3. HDBSCAN",
    "text": "3. HDBSCAN\nWe now perform HDBSCAN to cluster data based on the dimensionally reduced data from UMAP.\n\n3.1 Calculation\n\nimport hdbscan\n\nThe paper did not classify the minimum cluster size for HDBSCAN so I tried to find a parameter that fits. The minimum cluster size (clus_size) that fits the paper’s model is 19 as calculated by rounding 0.458 * to_plot.shape[1].\n\nconst = 0.8\nclus_size = round(const * to_plot.shape[1])\n\nmodel_ = hdbscan.HDBSCAN(clus_size)\nto_plot['hdbscan'] = model_.fit_predict(to_plot[['x', 'y']])\nto_plot = to_plot.sort_values(by='hdbscan', ascending=True)\nto_plot['hdbscan'] = to_plot['hdbscan'].astype(str)\nsns.relplot(data=to_plot, kind='scatter', x='x', y='y', hue='hdbscan')\n\n<seaborn.axisgrid.FacetGrid at 0x1bf9e264ac0>\n\n\n\n\n\n\n\n3.2 Comparison\nIn this section we present the data from Chen et al (2021).\n\nchen2021 = pd.read_csv('../data/raw/external/chen2021_classification.csv')\nchen2021['source'] = 'chen et al 2021'\nsns.relplot(data=chen2021, kind='scatter', x='embedding_x', y='embedding_y', hue='group')\n\n<seaborn.axisgrid.FacetGrid at 0x1bf9f7e1280>\n\n\n\n\n\nAs you can see, Chen et al (2021) contains 9 clusters while the one we did have 12 clusters. The number of clusters itself is irrelevant but the size of clusters is. What we want to know is whether or not we can replicate the classification of repeater clusters from non-repeater clusters.\nA cluster is considered repeater cluster is the total number of more than 10% repeating FRB exists in the cluster. Other FRBs inside the repeater cluster is determined to be ‘potentially’ repeating. Then, we compare the division between this notebook and Chen et al (2021).\n\n# Determining repeater clusters (>10% is repeater FRB)\nthis = to_plot[['tns_name','x','y', 'hdbscan', 'color']].rename(columns={'x': 'embedding_x', 'y':'embedding_y', 'hdbscan': 'label', 'color': 'repeater'})\nthis['source'] = 'calculated'\nthis['repeater'] = [False if name == 'non-repeater' else True for name in this['repeater']]\na = this.groupby('label').aggregate('mean', numeric_only=True)\na['group'] = ['repeater_cluster' if row > 0.1 else 'other_cluster' for row in a['repeater']]\na.reset_index()\nthis = this.merge(a[['group']], on='label')\n\n# Rename groups to only separate repeater clusters from other clusters\nchen2021['group'] = chen2021['group'].apply(lambda x: x[:-2])\n\ndata: pd.DataFrame = pd.concat([this, chen2021])\nsns.relplot(data=data, kind='scatter', x='embedding_x', y='embedding_y', hue='group', col='source')\n\n<seaborn.axisgrid.FacetGrid at 0x1bf9fb4bfa0>\n\n\n\n\n\nWe can see visually that the classification is not similar with Chen et. al. (2021)."
  },
  {
    "objectID": "notebooks/06-repeaters-and-non-repeaters-statisticaly-similar-ensembles.html",
    "href": "notebooks/06-repeaters-and-non-repeaters-statisticaly-similar-ensembles.html",
    "title": "Reproducing Cui Xiang-Han et. al (2020)‘s ’Fast radio bursts: do repeaters and non-repeaters originate in statistically similar ensembles?’",
    "section": "",
    "text": "Note\n\n\n\n📌 Goal: This notebook tries to reproduce the results from https://ui.adsabs.harvard.edu/abs/2021MNRAS.500.3275C/abstract. As stated in the paper, verbatim\n\nWe investigate the statistical classifications for the two groups of samples to see if the non-repeating and repeating FRBs have different origins by employing Anderson–Darling (A–D) test and Mann–WhitneyWilcoxon (M–W–W) test"
  },
  {
    "objectID": "notebooks/06-repeaters-and-non-repeaters-statisticaly-similar-ensembles.html#getting-the-data",
    "href": "notebooks/06-repeaters-and-non-repeaters-statisticaly-similar-ensembles.html#getting-the-data",
    "title": "Reproducing Cui Xiang-Han et. al (2020)‘s ’Fast radio bursts: do repeaters and non-repeaters originate in statistically similar ensembles?’",
    "section": "0. Getting The Data",
    "text": "0. Getting The Data\n\n0.1 Source\nThe data underlying said article are available in the references below:\n\nSpitler et al. (2016);\nCHIME/FRB Collaboration (2019a);\nKumar et al. (2019);\nCHIME/FRB Collaboration (2019b);\nFonseca et al. (2020).\n\nSome data of FRBs are taken from the data base of FRBCAT, available at http://www.frbcat.org/.\n\n0.1.1 Non-Repeaters\nHowever, I have not been able to effectively filter out repeater from the whole population in the FRBCAT Database. Therefore, I joined it with FRBSTATS where the repeater population has been listed on its utc column rounded to the nearest second.\n\n\n\n\n\n\nDeprecated\n\n\n\nSo I used the FRBSTATS1 as a proxy with the described filters:\n\nwidth <= 35\nis not identified as repeater\nThe FRB is observed between FRBCAT’s minimum dan maximum utc datetime\n\ntelescope is also available in the FRBCAT catalogue, except ‘CHIME/FRB’2\n\n\n\nUsing the described filters, I have been able to obtain 88 data points. It is close to the papers sample of 80 ~ 913\n\n# Load FRBCAT Catalogue\n\nfrbcat = pd.read_csv(\"../data/raw/external/frbcat_20221227.csv\", parse_dates=['utc']).rename(\n    columns={\n        'rop_sampling_time': 'sampling_time',\n        'rop_bandwidth': 'bandwidth_MHz',\n        'rop_centre_frequency': 'center_freq_MHz'\n        })\nfrbcat['utc'] = frbcat['utc'].round('S')\nfrbcat = frbcat[frbcat['rmp_width'] <= 35]\nfrbcat.info()\n\n<class 'pandas.core.frame.DataFrame'>\nInt64Index: 107 entries, 0 to 117\nData columns (total 14 columns):\n #   Column           Non-Null Count  Dtype         \n---  ------           --------------  -----         \n 0   frb_name         107 non-null    object        \n 1   utc              107 non-null    datetime64[ns]\n 2   telescope        107 non-null    object        \n 3   rop_raj          107 non-null    object        \n 4   rop_decj         107 non-null    object        \n 5   rop_gl           107 non-null    float64       \n 6   rop_gb           107 non-null    float64       \n 7   sampling_time    106 non-null    float64       \n 8   bandwidth_MHz    107 non-null    float64       \n 9   center_freq_MHz  107 non-null    float64       \n 10  rmp_dm           107 non-null    float64       \n 11  rmp_dm_error     107 non-null    float64       \n 12  rmp_width        107 non-null    float64       \n 13  rmp_snr          104 non-null    float64       \ndtypes: datetime64[ns](1), float64(9), object(4)\nmemory usage: 12.5+ KB\n\n\n\n# Load FRBSTATS catalogue and do appropriate filter\n\n# A separate list is used because FRBCAT uses a different name\nfrbstats_telescope_names_available_in_frbcat = ['Parkes', 'Arecibo', 'Pushchino', 'FAST', 'DSA', 'CHIME', 'WSRT/Apertif', 'UTMOST', 'VLA', 'GBT', 'ASKAP']\nfrbstats_float_columns = ['l', 'b', 'frequency', 'dm', 'flux', 'width', 'fluence', 'snr', 'redshift']\n\nrepeaters_samples = pd.read_csv('../data/raw/external/FRBSTATS2022-11-23_repeaters.csv', index_col=0)\nfrbstats = pd.read_csv('../data/raw/external/FRBSTATS2022-11-23_population.csv', \n    parse_dates=['utc'], \n    dtype={telescope: float for telescope in frbstats_telescope_names_available_in_frbcat},\n    na_values=[\"-\"]\n    )\nfrbstats['utc'].round('S')\n# Label repeaters\nfrbstats[\"repeater\"] = False\nfrbstats.loc[frbstats[\"frb\"].isin(repeaters_samples[\"samples\"]),\"repeater\"] = True\n\n# !! Filter is deprecated\n# selected_data = frbstats[\n#     (frbstats['repeater'] == False) & \n#     (frbstats[\"width\"] <= 35) &\n#     (frbstats[\"telescope\"].isin(frbstats_telescope_names_available_in_frbcat)) &\n#     (frbstats['telescope'] != 'CHIME') &\n#     (frbstats[\"utc\"].between(frbcat[\"utc\"].min(), frbcat[\"utc\"].max()))\n#     ]\n\nselected_data = pd.merge(frbcat[['utc', 'sampling_time', 'bandwidth_MHz', 'center_freq_MHz', 'rmp_width']], frbstats[frbstats['repeater'] == False], on='utc')\n\n# Handle NaN values\nselected_data.loc[selected_data['width'].isna(), ['width']] = selected_data['rmp_width']\nselected_data.loc[selected_data['sampling_time'].isna(), ['sampling_time']] = 0\n\nselected_data.info()\n\n<class 'pandas.core.frame.DataFrame'>\nInt64Index: 84 entries, 0 to 83\nData columns (total 25 columns):\n #   Column             Non-Null Count  Dtype         \n---  ------             --------------  -----         \n 0   utc                84 non-null     datetime64[ns]\n 1   sampling_time      84 non-null     float64       \n 2   bandwidth_MHz      84 non-null     float64       \n 3   center_freq_MHz    84 non-null     float64       \n 4   rmp_width          84 non-null     float64       \n 5   frb                84 non-null     object        \n 6   mjd                84 non-null     float64       \n 7   telescope          84 non-null     object        \n 8   ra                 84 non-null     object        \n 9   dec                84 non-null     object        \n 10  l                  84 non-null     float64       \n 11  b                  84 non-null     float64       \n 12  frequency          84 non-null     float64       \n 13  dm                 84 non-null     float64       \n 14  flux               77 non-null     float64       \n 15  width              84 non-null     float64       \n 16  fluence            81 non-null     float64       \n 17  snr                82 non-null     float64       \n 18  reference          84 non-null     object        \n 19  redshift           83 non-null     float64       \n 20  redshift_measured  6 non-null      float64       \n 21  ra_error           83 non-null     float64       \n 22  dec_error          83 non-null     float64       \n 23  dm_error           82 non-null     float64       \n 24  repeater           84 non-null     bool          \ndtypes: bool(1), datetime64[ns](1), float64(18), object(5)\nmemory usage: 18.5+ KB\n\n\nIn order the accept that both these data describe the same sample, I plotted the overlap between our selected data and the original FRBCAT data.\n\nfrbcat_ = frbcat.rename(columns={'frb_name':'frb','rop_raj': 'ra', 'rop_decj': 'dec', 'rop_gb': 'b', 'rop_gl': 'l', 'rmp_width': 'width', 'rmp_dm': 'dm', 'rmp_snr': 'snr'})\nfrbcat_.loc[:, ['source']] = 'frbcat'\nfrbstats_ = selected_data[['frb', 'utc', 'telescope', 'ra', 'dec', 'l', 'b', 'dm', 'width', 'snr']]\nfrbstats_.loc[:, ['source']] = 'frbstats'\nfrbpopulation_merged = pd.concat([frbcat_, frbstats_])\n\nsns.relplot(data=frbpopulation_merged, x='utc', y='width', style='source', hue='telescope')\n\n<seaborn.axisgrid.FacetGrid at 0x29d3b58f9a0>\n\n\n\n\n\n\n\n0.1.2 Repeaters\nData on repeaters are easy to obtain. The authors are kind enough to provide table on all 20 samples used in the study.\n\n\nxianghan = pd.read_csv('../data/raw/external/XiangHan2020_ensemble-repeaters.csv')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo.\nSources\nObserved width (ms)\nIntrinsic width (ms)\nFlux density (Jy)\nFluence (Jy ms)\nDistance (Gpc)\nRefs.\n\n\n\n\n0\n1\nFRB121102\n4.82\n4.78\n0.25\n0.372\n1.61\n(1)\n\n\n1\n2\nFRB180814.J0422+73\n22.57\n23.43\nnan\n22.57\n0.39\n(2)(3)\n\n\n2\n3\nFRB171019\n4.62\n4.08\nnan\n101.54\n1.89\n(4)\n\n\n3\n4\nFRB180916.J0158+65\n5.27\n5.16\n2.08\n1.62\n0.58\n(5)\n\n\n4\n5\nFRB181030.J1054+73\n1.01\n0.1\n3.15\n4.75\n0.24\n(5)\n\n\n5\n6\nFRB181128.J0456+63\n5.9\n5.8\n0.4\n3.45\n1.14\n(5)\n\n\n6\n7\nFRB181119.J12+65\n3.49\n3.33\n0.43\n1.77\n1.42\n(5)\n\n\n7\n8\nFRB190116.J1249+27\n2.75\n2.53\n0.35\n1.8\n1.9\n(5)\n\n\n8\n9\nFRB181017.J1705+68\n16.8\n16.73\n0.4\n8.5\n6.97\n(5)\n\n\n9\n10\nFRB190209.J0937+77\n6.55\n6.46\n0.5\n1.25\n1.66\n(5)\n\n\n10\n11\nFRB190222.J2052+69\n2.71\n2.48\n1.65\n5.45\n1.64\n(5)\n\n\n11\n12\nFRB190208.J1855+46\n1.11\n0.14\n0.5\n1.7\n2.35\n(6)\n\n\n12\n13\nFRB180908.J1232+74\n3.83\n3.7\n2.9\n0.5\n0.62\n(6)\n\n\n13\n14\nFRB190604.J1435+53\n2.1\n1.78\n0.75\n8.3\n2.42\n(6)\n\n\n14\n15\nFRB190212.J18+81\n3.1\n2.93\n0.75\n2.75\n1.05\n(6)\n\n\n15\n16\nFRB190303.J1353+48\n3.2\n3.04\n0.47\n2.67\n0.77\n(6)\n\n\n16\n17\nFRB190417.J1939+59\n4.5\n4.2\n0.53\n3.1\n7.4\n(6)\n\n\n17\n18\nFRB190117.J2207+17\n2.74\n2.53\n1\n6.36\n1.49\n(6)\n\n\n18\n19\nFRB190213.J02+20\n7\n6.9\n0.5\n1.8\n2.91\n(6)\n\n\n19\n20\nFRB190907.J08+46\n2.18\n1.92\n0.3\n2.03\n1.07\n(6)"
  },
  {
    "objectID": "notebooks/06-repeaters-and-non-repeaters-statisticaly-similar-ensembles.html#preprocessing",
    "href": "notebooks/06-repeaters-and-non-repeaters-statisticaly-similar-ensembles.html#preprocessing",
    "title": "Reproducing Cui Xiang-Han et. al (2020)‘s ’Fast radio bursts: do repeaters and non-repeaters originate in statistically similar ensembles?’",
    "section": "1.0 Preprocessing",
    "text": "1.0 Preprocessing\n\n1.1 Parameters\nWe first process our data to uncover these parameters:\n\nPulse width\nRadio Luminosity\n\n\n1.1.1 Pulse Width\nSince the pulse width in the FRBCAT is the observed width, which is easily affected by dispersion, to study the pulse width more accurately, we need to introduce the intrinsic width that is estimated by equation: \\[\nt_i = \\sqrt{t^2_\\text{obs} − t^2_\\text{DM} − t^2_s}\n\\] In the above formula, \\(t_i(t_\\text{obs})\\) is the intrinsic width (observed width), with \\(t_s\\) being the sampling time that depends on the instrument, and \\(t_\\text{DM}\\) is the dispersion smearing time-scale as calculated in the following: \\[\nt_\\text{DM} = 8.3 \\times 10^{−3} \\text{DM}\\frac{\\Delta ν_\\text{MHz}}{ν^3_\\text{GHz}} ms,\n\\] where DM is the dispersion measure, \\(\\Delta ν_\\text{MHz}\\) is the channel bandwidth in the unit of MHz, and \\(ν_\\text{GHz}\\) is the central frequency in the unit of GHz. Therefore, the pulse width in the following text represents the intrinsic width.\n\ndef dispersion_smearing_timescale(dispersion_measure, bandwidth_MHz, center_freq_GHz) -> float:\n    return 8.3e-6 * dispersion_measure * (bandwidth_MHz / center_freq_GHz**3)\n\ndef instrinsic_width(observed_width, sampling_time, dispersion_measure, bandwidth_MHz, center_freq_GHz) -> float:\n    return np.sqrt(abs((observed_width**2 - dispersion_smearing_timescale(dispersion_measure, bandwidth_MHz, center_freq_GHz)**2 - sampling_time**2)))\n\n\nselected_data.loc[:, 'intrinsic_width_ms'] = instrinsic_width(\n    selected_data['width'], \n    selected_data['sampling_time'], \n    selected_data['dm'], \n    selected_data['bandwidth_MHz'], \n    selected_data['center_freq_MHz']*0.001)\n\n\nfrbcat.loc[:, 'intrinsic_width_ms'] = instrinsic_width(\n    frbcat['rmp_width'],\n    frbcat['sampling_time'],\n    frbcat['rmp_dm'],\n    frbcat['bandwidth_MHz'],\n    frbcat['center_freq_MHz']*0.001\n)\n\n\n\n1.1.2 Radio Luminosity\nRadio luminosity is estimated using the formula below: \\[\n    L_\\text{radio} \\approx SD^2\n\\] where \\(S\\) is the flux density and \\(D\\) is the luminosity distance\n\nJy_to_erg_s = 1e-23 # erg s-1 cm-2 Hz-1\nGpc_to_m = 3.0857e16 * 1e6 # m\nm_to_cm = 100 #cm\n\ndef radio_luminosity_approx(flux_density: float, luminosity_distance: float) -> float:\n    \"\"\"Approximation of radio luminosity\n\n    Args:\n        flux_density (float): flux density in Jy\n        luminosity_distance (float): Luminosity distance in Gpc\n\n    Returns:\n        float: radio luminosity in erg/s /Hz\n    \"\"\"\n    flux_density_erg_s = flux_density*Jy_to_erg_s\n    luminosity_distance_cm = luminosity_distance*Gpc_to_m*m_to_cm\n    return flux_density_erg_s*(luminosity_distance_cm**2)\n\nThe formula for luminosity distance in this notebook is taken from the python implementation of\n\nc_km_s = 299792.458 # velocity of light in km/sec\nH_0_km_s_Mpc: float = 69.6 # km s^-1 Mpc^-1\ndef luminosity_distance(z: float, Omega_matter: float = 0.268, Omega_vacuum:float = 0.714, H_0_km_s_Mpc: float = 69.6) -> float:\n    \"\"\"Calculate luminosity distance at redshift based on the python's implementation of [CosmoCalc](https://www.astro.ucla.edu/~wright/CosmoCalc.html)\n\n    Args:\n        z (float): redshift\n        Omega_matter (float, optional): Total matter density. Defaults to 0.268.\n        Omega_vacuum (float, optional): Cosmological Constant. Defaults to 0.714.\n        H_0_km_s_Mpc (float, optional): Hubbles constant in km s^-1 Mpc^-1. Defaults to 69.6.\n\n    Returns:\n        float: Luminosity distance in Mpc\n    \"\"\"\n    h = H_0_km_s_Mpc/100.\n    Omega_radiation = 4.165E-5/(h*h)   # includes 3 massless neutrino species, T0 = 2.72528\n    Omega_curvature = 1-Omega_matter-Omega_radiation-Omega_vacuum\n\n\n    z = z[0]\n    az = 1.0/(1+1.0*z)\n    DTT = 0.0\n    DCMR = 0.0\n    n=1000         # number of points in integrals\n    # do integral over a=1/(1+z) from az to 1 in n steps, midpoint rule\n    for i in range(n):\n        a = az+(1-az)*(i+0.5)/n\n        adot = np.sqrt(Omega_curvature+(Omega_matter/a)+(Omega_radiation/(a*a))+(Omega_vacuum*a*a))\n        DTT = DTT + 1./adot\n        DCMR = DCMR + 1./(a*adot)\n\n    DTT = (1.-az)*DTT/n\n    DCMR = (1.-az)*DCMR/n\n\n    ratio = 1.00\n    x = np.sqrt(abs(Omega_curvature))*DCMR\n    if x > 0.1:\n        if Omega_curvature > 0:\n            ratio =  0.5*(np.exp(x)-np.exp(-x))/x \n        else:\n            ratio = np.sin(x)/x\n    else:\n        y = x*x\n        if Omega_curvature < 0: y = -y\n        ratio = 1. + y/6. + y*y/120.\n    DCMT = ratio*DCMR\n    DA = az*DCMT\n    DL = DA/(az*az)\n    DL_Mpc = (c_km_s/H_0_km_s_Mpc)*DL\n    return DL_Mpc\n\n\ndef redshift_from_distance(distance):\n    return distance*H_0_km_s_Mpc/c_km_s\n\n\nselected_data['radio_luminosity']   = radio_luminosity_approx(\n                                        selected_data['flux'], \n                                        luminosity_distance(z=selected_data['redshift'])*1000\n                                    )\nxianghan['radio_luminosity']        = radio_luminosity_approx(\n                                        xianghan['Flux density (Jy)'], \n                                        luminosity_distance(\n                                            z=redshift_from_distance(xianghan['Distance (Gpc)'])\n                                        )*1000\n                                    )\n\n\nselected_data['radio_luminosity'].describe()\n\ncount    7.700000e+01\nmean     1.661798e+39\nstd      2.601721e+39\nmin      3.006860e+36\n25%      4.780137e+37\n50%      5.396929e+38\n75%      2.081672e+39\nmax      1.137210e+40\nName: radio_luminosity, dtype: float64\n\n\n\nxianghan['radio_luminosity'].describe()\n\ncount    1.800000e+01\nmean     2.319993e+32\nstd      2.213047e+32\nmin      6.173843e+31\n25%      1.006336e+32\n50%      1.234769e+32\n75%      2.315191e+32\nmax      7.779042e+32\nName: radio_luminosity, dtype: float64\n\n\nWe can see that the range is not quite the same as stated in the paper:\n\nRepeaters: ∼1039 to ∼1042 erg s−1\nNon-repeaters: ∼1038 to ∼1044 erg s−1\n\nwhich possibly means that there are parts of the calculations that I am missing."
  },
  {
    "objectID": "notebooks/06-repeaters-and-non-repeaters-statisticaly-similar-ensembles.html#statistical-test",
    "href": "notebooks/06-repeaters-and-non-repeaters-statisticaly-similar-ensembles.html#statistical-test",
    "title": "Reproducing Cui Xiang-Han et. al (2020)‘s ’Fast radio bursts: do repeaters and non-repeaters originate in statistically similar ensembles?’",
    "section": "2.0 Statistical Test",
    "text": "2.0 Statistical Test\n\n2.1 Anderson–Darling Test\nAn Anderson–Darling test (A-D test) is used to measure the likelihood that a sample follows a certain distribution.\n\nfrom scipy.stats import anderson\n\nanderson_width_all = anderson([*xianghan['Intrinsic width (ms)'], *selected_data['intrinsic_width_ms'].dropna()], dist='norm')\nanderson_width_xianghan = anderson(xianghan['Intrinsic width (ms)'], dist='norm')\nanderson_width_nonrepeater = anderson(selected_data['intrinsic_width_ms'].dropna(), dist='norm')\n\n\n\n\n\n\n\n\n\n\n\n\n\nSample\nStatistic\nCritical values (\\(\\alpha\\) = 0.05)\n\n\n\n\n0\nAll data\n12.9237\n0.76\n\n\n1\nNon-repeating\n11.0479\n0.754\n\n\n2\nRepeating\n2.38607\n0.692\n\n\n\n\n\n\nanderson_lumo_all = anderson([*xianghan['radio_luminosity'].dropna(), *selected_data['radio_luminosity'].dropna()], dist='norm')\nanderson_lumo_xianghan = anderson(xianghan['radio_luminosity'].dropna(), dist='norm')\nanderson_lumo_nonrepeater = anderson(selected_data['radio_luminosity'].dropna(), dist='norm')\n\n\n\n\n\n\n\n\n\n\n\n\n\nSample\nStatistic\nCritical values (\\(\\alpha\\) = 0.05)\n\n\n\n\n0\nAll data\n13.3245\n0.757\n\n\n1\nNon-repeating\n9.08615\n0.751\n\n\n2\nRepeating\n2.24584\n0.687\n\n\n\n\n\nClearly, the results are different from what is stated from the paper.\n\nEven for the exact same data on the variable xianghan (Repeating) and the exact copy of the Intrinsic width (ms) parameters, the values are different. I have been trying to figure that out for about 3 weeks but no avail. Here are the things that I have tried:\n\nA custom Anderson-Darling function which yielded higher values.\nExcluding some values (No. 2, 12, 20) which yielded close enough statistic (1.43080) but I doubt that is the reason.\n\nI decided to stop trying and move on to something else."
  },
  {
    "objectID": "notebooks/07-post-HDBSCAN-statistics.html",
    "href": "notebooks/07-post-HDBSCAN-statistics.html",
    "title": "Comparing HDBSCAN classification statistically",
    "section": "",
    "text": "import pandas as pd\nimport seaborn as sns; sns.set_theme()\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "notebooks/07-post-HDBSCAN-statistics.html#getting-the-data",
    "href": "notebooks/07-post-HDBSCAN-statistics.html#getting-the-data",
    "title": "Comparing HDBSCAN classification statistically",
    "section": "0. Getting the Data",
    "text": "0. Getting the Data\n\n0.1 Source\nThis notebook will make use of classifications made by Chen, Bo Han et. al. (2022) and parameters calculated by Hashimoto, Tetsuya et. al. (2022).\n\nfrom pathlib import Path\n\nchen2022 = pd.read_csv(Path('..', 'data', 'raw', 'external', 'chen2022_classification.csv'))\nhashimoto2022 = pd.read_csv(Path('..', 'data', 'raw', 'external', 'Hashimoto2022_chimefrbcat1.csv'))\n\ndata = pd.merge(chen2022[['tns_name', 'group']], hashimoto2022, on='tns_name')\ndata\n\n\n\n\n\n  \n    \n      \n      tns_name\n      group\n      previous_name\n      repeater_name\n      ra\n      ra_err\n      ra_notes\n      dec\n      dec_err\n      dec_notes\n      ...\n      weight_fluence_error_m\n      weight\n      weight_error_p\n      weight_error_m\n      weighted_logrhoA\n      weighted_logrhoA_error_p\n      weighted_logrhoA_error_m\n      weighted_logrhoB\n      weighted_logrhoB_error_p\n      weighted_logrhoB_error_m\n    \n  \n  \n    \n      0\n      FRB20180725A\n      repeater_cluster_1\n      180725.J0613+67\n      -9999\n      93.42\n      0.04\n      -9999\n      67.10\n      0.20\n      -9999\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      1\n      FRB20180727A\n      other_cluster_6\n      180727.J1311+26\n      -9999\n      197.70\n      0.10\n      -9999\n      26.40\n      0.30\n      -9999\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      2\n      FRB20180729A\n      other_cluster_3\n      180729.J1316+55\n      -9999\n      199.40\n      0.10\n      -9999\n      55.58\n      0.08\n      -9999\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      3\n      FRB20180729B\n      repeater_cluster_1\n      180729.J0558+56\n      -9999\n      89.90\n      0.30\n      -9999\n      56.50\n      0.20\n      -9999\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      4\n      FRB20180730A\n      other_cluster_5\n      180730.J0353+87\n      -9999\n      57.39\n      0.03\n      -9999\n      87.20\n      0.20\n      -9999\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      784\n      FRB20190701A\n      other_cluster_1\n      -9999\n      -9999\n      277.50\n      0.20\n      -9999\n      59.00\n      0.20\n      -9999\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      785\n      FRB20190701B\n      other_cluster_5\n      -9999\n      -9999\n      302.90\n      0.20\n      -9999\n      80.20\n      0.20\n      -9999\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      786\n      FRB20190701C\n      repeater_cluster_3\n      -9999\n      -9999\n      96.40\n      0.20\n      -9999\n      81.60\n      0.30\n      -9999\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      787\n      FRB20190701D\n      other_cluster_3\n      -9999\n      -9999\n      112.10\n      0.20\n      -9999\n      66.70\n      0.20\n      -9999\n      ...\n      0.000649\n      1.361506\n      0.574701\n      0.206776\n      0.813142\n      0.485293\n      0.109293\n      0.894742\n      0.25519\n      0.19035\n    \n    \n      788\n      FRB20190701E\n      other_cluster_2\n      -9999\n      -9999\n      138.60\n      0.20\n      -9999\n      61.71\n      0.04\n      -9999\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n  \n\n789 rows × 108 columns"
  },
  {
    "objectID": "notebooks/07-post-HDBSCAN-statistics.html#preprocessing",
    "href": "notebooks/07-post-HDBSCAN-statistics.html#preprocessing",
    "title": "Comparing HDBSCAN classification statistically",
    "section": "1. Preprocessing",
    "text": "1. Preprocessing\n\n1.1 Calculating Parameters\n\n1.1.1 Intrinsic Width\nThe observed width is easily affected by dispersion, therefore we need to introduce the intrinsic width to study the pulse width more accurately. The intrinsic width is estimated by equation: \\[\nt_i = \\sqrt{t^2_\\text{obs} − t^2_\\text{DM} − t^2_s}\n\\tag{1}\\] In the above formula, \\(t_i(t_\\text{obs})\\) is the intrinsic width (observed width), with \\(t_s\\) being the sampling time that depends on the instrument, and \\(t_\\text{DM}\\) is the dispersion smearing time-scale as calculated in the following: \\[\nt_\\text{DM} = 8.3 \\times 10^{−3} \\text{DM}\\frac{\\Delta ν_\\text{MHz}}{ν^3_\\text{GHz}} ms,\n\\tag{2}\\] where DM is the dispersion measure, \\(\\Delta ν_\\text{MHz}\\) is the channel bandwidth in the unit of MHz, and \\(ν_\\text{GHz}\\) is the central frequency in the unit of GHz. Therefore, the pulse width in the following text represents the intrinsic width.\n\n\n\n1.2 Choosing Parameters\n\nintrinsic width (width_fb)1\nradio luminosity\nfluence (fluence)\nflux (flux)\nlog rest-frame intrinsic duration (logsubw_int_rest)\nradio energy in the logarithmic scale integrated over 400 MHz (logE_rest_400)\nhighest frequency (high_freq)\nlowest frequenc (low_freq)\npeak frequency (peak_freq)\n\n\ndata['diff_freq'] = data['high_freq'] - data['low_freq']\n\n\nidentifier_params = [\n    'tns_name',\n    'group'\n]\nselected_params = [\n    'logsubw_int_rest',\n    'logE_rest_400',\n    'high_freq',\n    'low_freq',\n    'peak_freq',\n    'flux',\n    'fluence',\n    'width_fitb',\n    'diff_freq'\n]\ndata = data[[*identifier_params, *selected_params]]\ndata\n\n\n\n\n\n  \n    \n      \n      tns_name\n      group\n      logsubw_int_rest\n      logE_rest_400\n      high_freq\n      low_freq\n      peak_freq\n      flux\n      fluence\n      width_fitb\n      diff_freq\n    \n  \n  \n    \n      0\n      FRB20180725A\n      repeater_cluster_1\n      -0.748199\n      40.208078\n      760.1\n      485.3\n      607.4\n      2.0\n      4.0\n      0.00030\n      274.8\n    \n    \n      1\n      FRB20180727A\n      other_cluster_6\n      -0.073706\n      39.791080\n      800.2\n      400.2\n      493.3\n      0.6\n      2.3\n      0.00140\n      400.0\n    \n    \n      2\n      FRB20180729A\n      other_cluster_3\n      -0.948762\n      38.880719\n      692.7\n      400.2\n      525.6\n      12.0\n      20.0\n      0.00010\n      292.5\n    \n    \n      3\n      FRB20180729B\n      repeater_cluster_1\n      -0.582195\n      38.561879\n      800.2\n      441.8\n      657.5\n      0.9\n      1.2\n      0.00031\n      358.4\n    \n    \n      4\n      FRB20180730A\n      other_cluster_5\n      -0.592583\n      41.127444\n      759.2\n      400.2\n      483.5\n      5.0\n      30.0\n      0.00047\n      359.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      784\n      FRB20190701A\n      other_cluster_1\n      -0.423913\n      39.639959\n      800.2\n      400.2\n      800.2\n      1.3\n      1.7\n      0.00061\n      400.0\n    \n    \n      785\n      FRB20190701B\n      other_cluster_5\n      -0.463004\n      39.870346\n      732.8\n      400.2\n      471.5\n      1.1\n      1.9\n      0.00060\n      332.6\n    \n    \n      786\n      FRB20190701C\n      repeater_cluster_3\n      -0.148206\n      40.362724\n      495.5\n      402.2\n      446.4\n      0.9\n      2.0\n      0.00140\n      93.3\n    \n    \n      787\n      FRB20190701D\n      other_cluster_3\n      -0.141426\n      40.835803\n      651.8\n      400.2\n      467.6\n      1.3\n      9.0\n      0.00140\n      251.6\n    \n    \n      788\n      FRB20190701E\n      other_cluster_2\n      -0.671894\n      39.964235\n      800.2\n      400.2\n      410.3\n      0.7\n      2.0\n      0.00040\n      400.0\n    \n  \n\n789 rows × 11 columns\n\n\n\n\nfrom itertools import combinations\nfrom scipy.stats import mannwhitneyu\n\nmix_match = pd.DataFrame([*combinations(data['group'].unique(), 2)], columns=['first', 'second'])\nmix_match['mww'] = mannwhitneyu(data[data['group'] == mix_match['first']]['width_fitb'], data[data['group']==mix_match['second']]['width_fitb'])\nmix_match\n\nValueError: Can only compare identically-labeled Series objects\n\n\n\nfor idx, (first, second) in enumerate(zip(mix_match['first'], mix_match['second'])):\n    result = mannwhitneyu(data[data['group'] == first]['width_fitb'], data[data['group'] == second]['width_fitb'])\n    # print(result.__dir__())\n    mix_match.loc[idx, ['mww_width']] = result.pvalue\n# mix_match.loc[:,['first']].values[0]\n\n\nmix_match\n\n\n\n\n\n  \n    \n      \n      first\n      second\n      mww_width\n    \n  \n  \n    \n      0\n      repeater_cluster_1\n      other_cluster_6\n      0.009313\n    \n    \n      1\n      repeater_cluster_1\n      other_cluster_3\n      0.000323\n    \n    \n      2\n      repeater_cluster_1\n      other_cluster_5\n      0.034013\n    \n    \n      3\n      repeater_cluster_1\n      other_cluster_2\n      0.021257\n    \n    \n      4\n      repeater_cluster_1\n      other_cluster_1\n      0.368829\n    \n    \n      5\n      repeater_cluster_1\n      repeater_cluster_3\n      0.201234\n    \n    \n      6\n      repeater_cluster_1\n      other_cluster_4\n      0.110173\n    \n    \n      7\n      repeater_cluster_1\n      repeater_cluster_2\n      0.014269\n    \n    \n      8\n      other_cluster_6\n      other_cluster_3\n      0.070644\n    \n    \n      9\n      other_cluster_6\n      other_cluster_5\n      0.649525\n    \n    \n      10\n      other_cluster_6\n      other_cluster_2\n      0.740351\n    \n    \n      11\n      other_cluster_6\n      other_cluster_1\n      0.702100\n    \n    \n      12\n      other_cluster_6\n      repeater_cluster_3\n      0.178768\n    \n    \n      13\n      other_cluster_6\n      other_cluster_4\n      0.973988\n    \n    \n      14\n      other_cluster_6\n      repeater_cluster_2\n      0.379427\n    \n    \n      15\n      other_cluster_3\n      other_cluster_5\n      0.382547\n    \n    \n      16\n      other_cluster_3\n      other_cluster_2\n      0.168447\n    \n    \n      17\n      other_cluster_3\n      other_cluster_1\n      0.201606\n    \n    \n      18\n      other_cluster_3\n      repeater_cluster_3\n      0.005728\n    \n    \n      19\n      other_cluster_3\n      other_cluster_4\n      0.175595\n    \n    \n      20\n      other_cluster_3\n      repeater_cluster_2\n      0.660534\n    \n    \n      21\n      other_cluster_5\n      other_cluster_2\n      0.722313\n    \n    \n      22\n      other_cluster_5\n      other_cluster_1\n      0.499936\n    \n    \n      23\n      other_cluster_5\n      repeater_cluster_3\n      0.161985\n    \n    \n      24\n      other_cluster_5\n      other_cluster_4\n      0.605066\n    \n    \n      25\n      other_cluster_5\n      repeater_cluster_2\n      0.716361\n    \n    \n      26\n      other_cluster_2\n      other_cluster_1\n      0.803334\n    \n    \n      27\n      other_cluster_2\n      repeater_cluster_3\n      0.164067\n    \n    \n      28\n      other_cluster_2\n      other_cluster_4\n      0.559644\n    \n    \n      29\n      other_cluster_2\n      repeater_cluster_2\n      0.517584\n    \n    \n      30\n      other_cluster_1\n      repeater_cluster_3\n      0.802093\n    \n    \n      31\n      other_cluster_1\n      other_cluster_4\n      0.971454\n    \n    \n      32\n      other_cluster_1\n      repeater_cluster_2\n      0.386282\n    \n    \n      33\n      repeater_cluster_3\n      other_cluster_4\n      0.401549\n    \n    \n      34\n      repeater_cluster_3\n      repeater_cluster_2\n      0.089872\n    \n    \n      35\n      other_cluster_4\n      repeater_cluster_2\n      0.452530\n    \n  \n\n\n\n\n\nfor param in selected_params:\n    sns.ecdfplot(data, x=param, hue='group')\n    plt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Label randomly\n\nimport random\n\ncontrol = data.copy()\nrandom.shuffle(control['group'])\ndata['classification'] = 'Chen et. al (2022)'\ncontrol['classification'] = 'random'\n\nfor param in selected_params:\n    g = sns.FacetGrid(pd.concat([data, control]), col='classification', hue='group')\n    g.map(sns.ecdfplot, param)\n    g.add_legend()\n    plt.show()\n\nC:\\Users\\LENOVO\\.pyenv\\pyenv-win\\versions\\3.8.10\\lib\\random.py:307: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  x[i], x[j] = x[j], x[i]\nC:\\Users\\LENOVO\\AppData\\Local\\Temp\\ipykernel_12464\\293886728.py:7: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  data['classification'] = 'Chen et. al (2022)'"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This repository is meant to document my Masters in Physics’ work under Dr Noriah Hashim and Dr Zamri Zainal in University Malaya.\n\n\nThese problem statements are as follows:\n\nCan we use machine learning techniques to help classify Fast Radio Bursts (FRBs)?\nIf machine learning algorithms uncover more than a binary classification of repeating and non-repeating FRBs, is it possible that they are sampled from different origins?\n\n(modified 2023-01-11)\n\n\n\n\nThe cfod package used to access the CHIME/FRB catalog requires Linux or WSL.\nThe fruitbat package used to calculate redshift requires Linux or WSL.\n\n\n\n\n\nPhantom Data (Refer to Affan. It relates to how his Polar BEAR detects phantom data)\nClassification of repeating FRBs\nTrends of 800 FRB / Possible Predict Periodicity for repeater candidates\nNew FRB\nUnique Old FRB"
  }
]